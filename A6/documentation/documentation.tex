\documentclass[11pt]{scrartcl}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{ngerman}
\usepackage{amsmath,amssymb,amstext}
\usepackage{graphicx}
\usepackage[automark]{scrpage2}
\usepackage{pgfplots}
\usepackage{chngcntr}
\usepackage[left=3cm, right=3cm, top=3cm, bottom=3cm]{geometry}
\counterwithin{figure}{section}

\pagestyle{scrheadings}

\title{Hybrid-Quicksort}
\author{Finn Jannsen, Philipp Schwarz}
\date{\today{}}

\begin{document}

\maketitle

\tableofcontents

\section{Einführung}
	\label{sec:einfuehrung}
	
	Diese Dokumentation beschreibt eine Sortieralgorithmus-Implementation für Arrays, basierend auf Quicksort.
	Für den Algorithmus wurden Optimierungen ausgeführt, die reduzierte Laufzeit und effiziente Resourcennutzung zum Ziel haben.
	In Abschnitt \ref{sec:implementation} wird darauf eingegangen, wie der Algorithmus realisiert wurde.
	Anschließend wird in Abschnitt \ref{sec:veri} geprüft, ob die Implementation korrekt funktioniert 
	und in Abschnitt \ref{sec:aufwand} die Performance mit dem zu Grunde liegenden Quicksort verglichen.

\section{Implementation}
	\label{sec:implementation}
	
	Der Algorithmus wurde als Kasse realisiert, der ein Interface implementiert, welches es ermöglicht, einfach weitere Implementationen, sofern dies gewünscht wird, zu schreiben.

	\subsection{Pivotauswahl}
		\label{sec:pivAus}
		
		Bei der Untersuchung von Quicksort stellte sich eine Methode zur Pivot-Auswahl am effizientesten auf: Median-of-three.
		Der mittlere Wert von mehreren Key-Werten (bei Bedarf auch von mehr als 3) sorgt für eine gleichmäßigere Aufteilung der Partitionierung beim Sortieren.
		Dadurch finden im allgemeinen weniger Iterationen als bei anderen Pivots, wie z.B. Random oder Right statt, was wünschenswert ist.
 
		Der Code ist in \ref{figure:pivotCode} dargestellt. Eins von 3 Elementen wird in die Mitte getauscht und als Pivot ausgewählt.
	
	\subsection{Sortieren}
		\label{sec:sortAlgo}
		
		Der Algorithmus der Sortiert ist im wesentlichen eine Schleife, in der zuerst das erste Element von links, welches gleich oder größer als Pivot ist, gesucht wird.
		Danach wird das erste Element von rechts, welches kleiner als das Pivot ist, gesucht. Diese werden dann getauscht.
		Die Schleife wird verlassen, wenn die jeweiligen Such-Schleifen einander kreuzen.
		Danach wird das Pivot in diese Mitte an Stelle i zurückgetauscht und der Algorithmus wird zwei mal rekursiv gestartet,
		einmal um die Liste von ganz links bis i-1 zu sortieren und noch einmal um die Liste von i+1 bis rechts zu sortieren.

		Der Code ist in \ref{figure:sortCode} dargestellt.

	\subsection{Optimierung}
		\label{sec:optAlgo}

		%%TODO

\section{Testen und Verifikation}
\label{sec:vertests}

	\subsection{Verifizieren}
		\label{sec:veri}
		
		Der Algorithmus wurde auf seine korrekte Funktionalität getestet.
		Hierzu zählt natürlich das Vorliegen des Ergebnisses in der korrekten Reihenfolge.
		Alle Tests wurden erfolgreich mit unterschiedlichen Eingabewerten absolviert.
	
	\subsection{Aufwandsanalyse}
		\label{sec:aufwand}
		
		Für die Aufwandsanalyse wurde der Klasse ein Counter eingeführt, der die Tauschoperationen zählt. 
		
		Bisherige Untersuchungen von Quicksort haben bereits einen Asymptotischen Aufwand wie folgt ergeben:

		Rechenoperationen bei Best- und Average Case:
		\begin{equation*}
		T(n) = \mathcal{O}(n*ln(n))
		\end{equation*}
		Rechenoperationen bei Worst Case:
		\begin{equation*}
		T(n) = \mathcal{O}(n^{2})
		\end{equation*}

		Dieses mal wurden statt komplett zufälligen Key-Werten welche mit folgender Beschränkung ausgewählt: 
		\begin{equation*}
		700*N \leq key \leq 800*N
		\end{equation*}
		Dies hat zur Folge, dass in der zu sortierenden Menge vermehr duplizierte Keys auftreten. 
		Um unter anderem mit dieser Hürde besser umgehen zu können wurden die in \ref{sec:optAlgo} angesprochenen Optimierungen eingeführt.
		Es wurden 10 Durchläufe des Tests mit den Größen $N=10^k, k=1,...,6$ durchgeführt, um einen angemessenen Mittelwert zu ermitteln.
		Die Beobachtungen der Rechenoperationen und Laufzeit sind in den Abbildungen \ref{figure:operTest} und \ref{figure:timeTest} zu sehen.\\

		%%Beobachtungen auswerten

\begin{figure}
    \newcommand{\motCol}{green}
    \newcommand{\rightCol}{blue}
    \newcommand{\ranCol}{red}
    \newcommand{\bestAvgMark}{square*}
    \newcommand{\transparent}{0.6}
    \makebox[\textwidth][c]{
    \begin{tikzpicture}
        \begin{loglogaxis}[
                title={\large Berechnung Operationen},
                height=10cm,
                width=17cm,
                grid=major,
                x tick label style={
                /pgf/number format/1000 sep=},
                ylabel=Operationen,
                xlabel=Anzahl Elemente,
                enlargelimits=0.05,
                legend style={at={(0.5,-0.15)},
                anchor=north,legend columns=1},
            ]
            \addplot[color=\motCol,mark=\bestAvgMark,opacity=\transparent]
                coordinates {(1,0)(10,18)(100,198)(1000,1998)(10000,19998)(100000,200002)};
            \addplot[color=\ranCol,mark=\bestAvgMark,opacity=\transparent]
                coordinates {(1,0)(10,18)(100,198)(1000,1998)(10000,19998)(100000,199994)};
            \addplot[color=\rightCol,mark=\bestAvgMark,opacity=\transparent]
                coordinates {(1,0)(10,9)(100,99)(1000,999)(10000,9999)(100000,100002)};
            \legend{Median-of-Three, Random, Right}
        \end{loglogaxis}
    \end{tikzpicture}
    }
    \caption{Quantitativer Vergleich zu Quicksort anhand Rechenoperationen}
    \label{figure:operTest}
\end{figure}

\begin{figure}
    \newcommand{\motCol}{green}
    \newcommand{\rightCol}{blue}
    \newcommand{\ranCol}{red}
    \newcommand{\worstMark}{*}
    \newcommand{\transparent}{0.6}
    \makebox[\textwidth][c]{
    \begin{tikzpicture}
        \begin{loglogaxis}[
                title={\large Berechnung Operationen},
                height=10cm,
                width=17cm,
                grid=major,
                x tick label style={
                /pgf/number format/1000 sep=},
                ylabel=Operationen,
                xlabel=Anzahl Elemente,
                enlargelimits=0.05,
                legend style={at={(0.5,-0.15)},
                anchor=north,legend columns=1},
            ]
            \addplot[color=\motCol,mark=\worstMark,opacity=\transparent]
                coordinates {(1,0)(10,27)(100,297)(1000,2997)(10000,29997)(100000,299997)};
            \addplot[color=\ranCol,mark=\worstMark,opacity=\transparent]
                coordinates {(1,0)(10,27)(100,297)(1000,2997)(10000,29997)(100000,299997)};
            \addplot[color=\rightCol,mark=\worstMark,opacity=\transparent]
                coordinates {(1,0)(10,9)(100,99)(1000,999)(10000,9999)(100000,99999)};
            \legend{Median-of-Three, Random, Right}
        \end{loglogaxis}
    \end{tikzpicture}
    }
    \caption{Quantitativer Vergleich zu Quicksort anhand Laufzeit}
    \label{figure:timeTest}
\end{figure}

\begin{figure}
\begin{verbatim}
//find pivot with median of 3
int center = (left + right) / 2;

if (list[left].getKey() > list[center].getKey()) {
    increaseCounter();
    swap(list, left, center);
}
if (list[left].getKey() > list[right].getKey()) {
    increaseCounter();
    swap(list, left, right);
}
if (list[center].getKey() > list[right].getKey()) {
    increaseCounter();
    swap(list, center, right);
}
\end{verbatim}
\caption{Code-Ausschnitt Pivotsuche}
\label{figure:pivotCode}
\end{figure}


\begin{figure}
\begin{verbatim}
iterationLoop:
while (true) {
    // increase i, which starts as the smallest index, until the Node it indexes is equal or larger than the pivot
    while (list[i].getKey() < list[pivot].getKey()) {
        increaseCounter();
        i++;
    }

    // decrease j, which starts as the largest index, until the Node it indexes is smaller than the pivot
    while (j > i && list[j].getKey() >= list[pivot].getKey()) {
        increaseCounter();
        j--;
    }

    // break out of the loop when we iterated over every entry
    if (i >= j) {
        break iterationLoop;
    }
    // swap i, which points at an element larger than the pivot with j, which points at an element smaller than the pivot
    swap(list, i, j);
}

// swap the pivot to the right part
swap(list, i, right);
// sort everything right and left of the pivot
sort(list, left, i-1, pivotType);
sort(list, i+1, right, pivotType);
\end{verbatim}
\caption{Code-Ausschnitt Sortieren}
\label{figure:sortCode}
\end{figure}

\end{document}